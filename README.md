This repository is for the course CS497.
Homework, ect will be put on here. I will also include explanations on details of algorithms and complexity analysis/efficiency.
Assignment 1
Problem 1: I started by storing the given data (number list, target) in a dictionary. I then iterate over the list and calculate the number complement to reach the target sum. If a pair is found then it is returned and their positions in the dictionary is printed out, like [0, 1]. This code basically checks over the given dictionary while checking for number complements, and if it is unable to find it initially the number complements get stored for later use in case a solution comes up later.
This runs in O(n) time complexity. I tried avoiding using more loops, or nested loops specifically since that could end up adding to the time complexity. I spent a bit of time looking up how to use Python dictionaries for quick searches after initially trying out loops that looked over the whole thing multiple times. This should(?) be a more optimal solution than the nested loops I mentioned beforehand, but I'm not sure if I can further optimize it. Plus, I can return the indices more easily with fewer lines.
Problem 2: Since I'm looking for a target number in an array, at the very start I made a check to see if the number even exists in the array at all. This lets me quickly return an aswer without having to spend more time doing something. The first search is pretty basic and straightforward; just start searching from the beginning to the end. I spent some time trying to figure out how to find the ending position in the list. Initially I thought up of instantly cutting to where the first number was found then search forward from there, adding the amount of numbers skipped to the found number position to correct it. Then I remembered that I could actually reverse the list and search "forward", which seemed a lot less convoluted than my other idea. The "- 1" exists to correct the position of where a number is found since its reversed, otherwise it'd end up repeating the same number as the forward search.
I think this runs in O(n) time complexity, it can kinda depend based on the list length. Otherwise it should be fairly simple in runtime since its just searching a list twice, otherwise just returning nuber not found.
