Assignment 3

Problem 1: So taking in an inputted array, then converting it to a binary search tree. Since the list is already sorted, I can just split it down the middle and assign the left and right sides in the tree then recursively assign elements to left and right.
I had a lot of problems making the actual sorting and ordering of the output work, I guess something in the tree was being placed wrongly? I looked up what could be going wrong and at some point I got it to work, but honestly I have no clue what I changed.
Most of the stuff should just be O(n) time complexity, sorting arrays and going through them.
I used https://www.geeksforgeeks.org/binary-search-tree-in-python/ to try to figure out how to implement binary search trees along with class slides.

Problem 2: Preorder and inorder arrays, turn them into a binary tree. First thing to do is take the root node of the subtree and once that is done, slicing the preorder list to move elements left of the root
to the left subtree and right to the right subtree. I don't know how to use hash maps well on this so I just tried recursively adding stuff to the left and right side. It's slower on time complexity with up to about O(n^2),
or usually just O(n). A FIFO queue for the root helps to append and pop elements in the queue for managing the tree. I'm not sure what else to do since that was the most familiar solution I could think of at the moment.
https://www.geeksforgeeks.org/preorder-traversal-of-binary-tree/

Problem 3: So, a path in a binary tree has the node, the left, and the right branches. So how should I add stuff from each node, to make the final sum? I figured some way of looping could probably work since it's gonna be 
going through elements to add. But I also need some way to deal with negative integers since example 2 has -10 in it. I figured that if I initially set the maximum sum to negative infinity which, technically, is smaller
than any real number in python, lets me have the first comparison be replaces by a better sum path. This mostly came from troubleshooting an issue with negative integers giving my program trouble, and I found that online.
It's also kinda funny to have negative infinity be a thing.
leftMax and rightMax allow me to find the best sum path while also getting rid of negative elements. It returns the largest combination of two elements, since that's what I want for the optimal sum.
I tried BFS first but that seemed to work less well, and I ended up writing too much to make it actually work in the first place. Depth first search did better since it returns the max sum from a path and it 
lets me update the global max with the optimal path from the left and right nodes.
This code runs in O(n) time because it visits each node exactly once. Itâ€™s fairly optimal since we have to look at each node at least once, and we avoid any repeated calculations.
